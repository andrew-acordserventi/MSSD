package week5;

import java.util.ArrayList;
import java.util.Random;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class hw4_main {
    // arraylist to hold our genomes
    public static ArrayList<String> genomes = new ArrayList<String>();

    public static void main(String[] args) throws InterruptedException {
        // creating variables to use to track/compare time
        long startTime, endTime;
        long manualTime = 0;
        long threadedTime = 0;

        // sets the size of our array to build to the number of unique (but not necessarily different sequences) genomes
        int genomeArraySize = 100_000_000;
        //int genomeArraySize = 10000;

        System.out.println("Creating " + genomeArraySize + " genomes manually.");
        startTime = System.nanoTime();
        // loops 100 times to make 100 genomes
        for (int i = 0; i < genomeArraySize; i++) {

            // builds an individual genome
            genomes.add(buildGenome());
        }
        endTime = System.nanoTime();
        manualTime += endTime - startTime;
        System.out.println(genomeArraySize + " genomes created... Clearing array...");

        System.out.println("Manual time is " + manualTime + "ns\n");

        // for later comparison
        int manualSize = genomes.size();

        // prints genomes; test purposes - uncomment to ensure the arrays generated by threading vs manual are different
        //printGenomes();

        // clears our array so threads can recreate a new array
        genomes.clear();

        Lock lock = new ReentrantLock();

        int numThreads = 5;

        // creating 5 new threads, splitting up our genome building in 5 parts
        Thread t1 = new Thread() {
            public void run() {
                for (int i = 0; i < (genomeArraySize/numThreads); i++) {
                    lock.lock();
                    genomes.add(buildGenome());
                    lock.unlock();
                }
            }
        };

        Thread t2 = new Thread() {
            public void run() {
                for (int i = 0; i < (genomeArraySize/numThreads); i++) {
                    lock.lock();
                    genomes.add(buildGenome());
                    lock.unlock();
                }
            }
        };

        Thread t3 = new Thread() {
            public void run() {
                for (int i = 0; i < (genomeArraySize/numThreads); i++) {
                    lock.lock();
                    genomes.add(buildGenome());
                    lock.unlock();
                }
            }
        };

        Thread t4 = new Thread() {
            public void run() {
                for (int i = 0; i < (genomeArraySize/numThreads); i++) {
                    lock.lock();
                    genomes.add(buildGenome());
                    lock.unlock();
                }
            }
        };

        Thread t5 = new Thread() {
            public void run() {
                for (int i = 0; i < (genomeArraySize/numThreads); i++) {
                    lock.lock();
                    genomes.add(buildGenome());
                    lock.unlock();
                }
            }
        };

        System.out.println("Creating " + genomeArraySize + " genomes using threads.");
        // running our threads and measuring the time
        startTime = System.nanoTime();
        // TODO need a start lock here...
        t1.start();
        t2.start();
        t3.start();
        t4.start();
        t5.start();
        t1.join();
        t2.join();
        t3.join();
        t4.join();
        t5.join();
        // TODO need an end lock here
        endTime = System.nanoTime();
        threadedTime += endTime - startTime;
        System.out.println(genomeArraySize + " genomes created.");

        System.out.println("Threaded time is " + threadedTime + "ns\n");

        //printGenomes();

        int threadedSize = genomes.size();

        System.out.println("Genome creation verification: Manual size: " + manualSize +
                ", thread size: " + threadedSize);

        System.out.println("Manual time: " + manualTime + "ns");
        System.out.println("Threaded time: " + threadedTime + "ns\n");

        // comparing and printing results
        long compareTime = manualTime - threadedTime;
        if (compareTime >= 0)
            System.out.println("Threaded time was quicker by " + compareTime + "ns");
        else if (compareTime < 0)
            System.out.println("Manual runtime was quicker by " + compareTime*(-1) + "ns");
    }

    /**
     * Builds an individual genome. Returns the genome built as a String.
     */
    public static String buildGenome() {
        // random variables for later use in making sequences
        Random r = new Random();
        // holder for each individual genome sequence
        StringBuilder individualSequence = new StringBuilder();

        // loops 10 times to make one individual sequence
        for (int k = 0; k < 10; k++) {

            // randomly picks a number 0-3
            int rand_int1 = r.nextInt(4);

            // random number determines the A,T,C,G and appends it to our stringbuilder
            if (rand_int1 == 0) {
                individualSequence.append("A");
            }
            else if (rand_int1 == 1) {
                individualSequence.append("T");
            }
            else if (rand_int1 == 2) {
                individualSequence.append("C");
            }
            else if (rand_int1 == 3) {
                individualSequence.append("G");
            }
        }

        // adds the individual sequence to our arraylist of genomes
        String sequenceString = individualSequence.toString();
        return sequenceString;
    }


    /**
     * Prints out the list of genomes.
     * Mainly for testing purposes to ensure arrays are cleared and different when generated from threads vs. manually.
     */
    public static void printGenomes() {
        // prints arraylist of genomes
        for (int i = 0; i < genomes.size(); i++) {
            System.out.println((i+1) + ". " + genomes.get(i).toString());
        }
    }
}
